import torch as tc
from modules.utils import *

def primal_dual(xb, D, B, grad, sub, sup, P, N, tau):
    """
    Batch version of the primal-dual update with per-sample directional matrices.
    
    Inputs:
      xb:   tensor of shape (P, N) – signal (after projection)
      D:    tensor of shape (P, L, N) – directional matrices per sample
      B:    tensor of shape (P, L, L) – corresponding B matrices per sample
      grad: tensor of shape (P, N)
      sub, sup: scalar parameters for the inner loop
    
    Returns:
      x:  updated signal tensor of shape (P, N)
      dx: applied update, tensor of shape (P, N)
    """
    device = xb.device
    dtype  = xb.dtype

    # Tout sur le même device
    D    = D.to(device)
    B    = B.to(device)
    grad = grad.to(device)

    L = D.size(1)  # lmbdmber of directions per sample

    # Symmetrize B per sample
    B = 0.5 * (B + B.transpose(1, 2))  # (P, L, L)

    # Initialize dual variables per sample (direct GPU alloc)
    un = tc.zeros((P, L), dtype=dtype, device=device)
    vn = tc.zeros((P, N), dtype=dtype, device=device)

    # 1) Calcul de la norme ℓ₂ par échantillon (sur L*N)
    norm_D = tc.norm(D.reshape(P, -1), p=2, dim=1)  # (P,)

    # 2) delta et gamma sont des vecteurs (P,)
    delta = 1.0 / norm_D
    gamma = 1.0 / norm_D

    # 3) Pré-calcul de (I + δ B)^{-1}
    eye = tc.eye(L, dtype=dtype, device=device).unsqueeze(0).expand(P, L, L)
    eyemu = eye + delta.view(P, 1, 1) * B            # (P, L, L)
    inv_eyemu = tc.linalg.inv(eyemu)                 # (P, L, L)

    # Boucle interne
    for _ in range(sub, sup + 1):
        # u = un - μ * (vn @ D^T)
        u = un - delta.view(P, 1) * tc.bmm(vn.unsqueeze(1), D.transpose(1, 2)).squeeze(1)  # (P,L)

        # prox step
        temp = tc.bmm(grad.unsqueeze(1), D.transpose(1, 2)).squeeze(1)  # (P,L)
        pn   = u - delta.view(P, 1) * temp                               # (P,L)
        pn   = tc.bmm(pn.unsqueeze(1), inv_eyemu).squeeze(1)             # (P,L)

        # v update avec ν broadcasté sur (P,N)
        v  = vn + gamma.view(P, 1) * tc.bmm((2 * pn - un).unsqueeze(1), D).squeeze(1)  # (P,N)
        qn = v + gamma.view(P, 1) * xb - gamma.view(P, 1) * proj_simplex(v / gamma.view(P, 1) + xb)

        if (tc.all(pn-qn)< 0.0085):
            break

        un = un + tau * (pn - un)
        vn = vn + tau * (qn - vn)

    dx = tc.bmm(un.unsqueeze(1), D).squeeze(1)  # (P, N)
    x = xb + dx
    return x, dx


def init_PD(sub_static_input):

    xb, D, B, grad, sub, sup, P, N, tau = sub_static_input

    device = xb.device
    dtype  = xb.dtype

    # Tout sur le même device
    D    = D.to(device)
    B    = B.to(device)
    grad = grad.to(device)

    L = D.size(1)  # lmbdmber of directions per sample

    # Symmetrize B per sample
    B = 0.5 * (B + B.transpose(1, 2))  # (P, L, L)

    # Initialize dual variables per sample (direct GPU alloc)
    un = tc.zeros((P, L), dtype=dtype, device=device)
    vn = tc.zeros((P, N), dtype=dtype, device=device)

    # 1) Calcul de la norme ℓ₂ par échantillon (sur L*N)
    norm_D = tc.norm(D.reshape(P, -1), p=2, dim=1)  # (P,)

    # 2) delta et gamma sont des vecteurs (P,)
    delta = 1.0 / norm_D
    gamma = 1.0 / norm_D

    # 3) Pré-calcul de (I + δ B)^{-1}
    eye = tc.eye(L, dtype=dtype, device=device).unsqueeze(0).expand(P, L, L)
    eyemu = eye + delta.view(P, 1, 1) * B            # (P, L, L)
    inv_eyemu = tc.linalg.inv(eyemu)                 # (P, L, L)
    
    u_new = [un, vn]
    sub_static = [xb, grad, P, D, inv_eyemu, gamma, delta]

    return u_new, sub_static 

def iter_PD(sub_static, u_new, tau):

    xb, grad, P, D, inv_eyemu, gamma, delta = sub_static

    un, vn = u_new

    # u = un - μ * (vn @ D^T)
    u = un - delta.view(P, 1) * tc.bmm(vn.unsqueeze(1), D.transpose(1, 2)).squeeze(1)  # (P,L)

    # prox step
    temp = tc.bmm(grad.unsqueeze(1), D.transpose(1, 2)).squeeze(1)  # (P,L)
    pn   = u - delta.view(P, 1) * temp                               # (P,L)
    pn   = tc.bmm(pn.unsqueeze(1), inv_eyemu).squeeze(1)             # (P,L)

    # v update avec ν broadcasté sur (P,N)
    v  = vn + gamma.view(P, 1) * tc.bmm((2 * pn - un).unsqueeze(1), D).squeeze(1)  # (P,N)
    qn = v + gamma.view(P, 1) * xb - gamma.view(P, 1) * proj_simplex(v / gamma.view(P, 1) + xb)

    un = un + tau * (pn - un)
    vn = vn + tau * (qn - vn)

    u_new = [un, vn]

    return u_new

def init_P3MG(static_input, x0, y):
    """
    Étape 0 : Initialisation, chargement des données, définition des variables
    et calculs préliminaires.

    Entrées :
      static_input : list/tuple (alpha, beta, eta, sub, sup)
      x0           : (P, N)
      y            : (P, M)

    Renvoie :
      (Hmat, alpha, beta, eta, sub, sup, gamma, Cg2, Vprec, Sprec_2, Hnorm2)
    """
    P, N, M = x0.size(0), x0.size(1), y.size(1)

    alpha, beta, eta, sub, sup = static_input

    # génération de Hmat sur CPU (on le passera au GPU dans iter_*)
    T, Hmat = dosy_mat(
        int(N),   # nombre de D-values
        int(M),   # nombre de points temporels
        0,        # tmin
        1.5,      # tmax
        1,        # Dmin
        1000,     # Dmax
        dtype=x0.dtype
    )

    # Constantes
    Cg2    = 9 / (N * 8 * eta**2)
    Hnorm2 = tc.norm(Hmat, 2) ** 2
    gamma  = 1.9

    # SVD préconditionnement (CPU puis transfert à la demande)
    rankprec = 10
    Uprec, Sprec, VprecT = tc.linalg.svd(Hmat, full_matrices=False)
    Vprec    = VprecT.t()[:, :rankprec]          # (N, r)
    Sprec    = Sprec[:rankprec]                   # (r,)
    Sprec_2  = 1.0 / (Sprec ** 2)                 # (r,)

    return Hmat, alpha, beta, eta, sub, sup, gamma, Cg2, Vprec, Sprec_2, Hnorm2


def iter_P3MG_base(static, x, y, lmbd, tau):
    """
    Première itération P3MG.
    """
    P, N, M = x.size(0), x.size(1), y.size(1)

    Hmat, alpha, beta, eta, sub, sup, gamma, Cg2, Vprec, Sprec_2, Hnorm2 = static

    LipsMaj = lmbd * (1 / (alpha * beta) + Cg2) + Hnorm2

    device = x.device
    dtype  = x.dtype

    # Statics -> device
    Hmat    = Hmat.to(device=device, dtype=dtype)
    Vprec   = Vprec.to(device=device, dtype=dtype)
    Sprec_2 = Sprec_2.to(device=device, dtype=dtype)

    # Gradient
    gradx, l1 = gradient_x(x, y, Hmat, alpha, beta, eta, lmbd)

    # Pas de descente + projection
    forward = x - (gamma / LipsMaj) * gradx
    xb      = proj_simplex(forward)
    Pgradx  = xb - x

    gradxb, l1b = gradient_x(xb, y, Hmat, alpha, beta, eta, lmbd)

    # Sous-espace (itération 1)
    Dx_list = []
    subspace_iter1 = [1, 0]
    if subspace_iter1[0]:
        Dx_list.append(Pgradx)
    if subspace_iter1[1]:
        # Majorant diagonal (batch)
        Adiag0     = majorante_x_diag(x, alpha, l1, beta, Cg2, lmbd, 0)   # (P, N)
        Delta_inv  = 1.0 / Adiag0                                       # (P, N)
        Vprec_T    = Vprec.t().unsqueeze(0).expand(P, -1, -1)           # (P, r, N)
        weighted_V = Vprec_T * Delta_inv.unsqueeze(1)                   # (P, r, N)
        temp_batch = tc.bmm(weighted_V, Vprec.unsqueeze(0).expand(P, -1, -1))  # (P, r, r)
        diag_S     = tc.diag_embed(Sprec_2).unsqueeze(0).expand(P, -1, -1)     # (P, r, r)
        temp       = diag_S + temp_batch                                 # (P, r, r)

        # Préconditionnement du gradient
        Prec_gradx = Delta_inv * gradx                                   # (P, N)
        temp_vec   = tc.matmul(Prec_gradx, Vprec)                         # (P, r)
        sol        = tc.linalg.solve(temp, temp_vec.unsqueeze(-1)).squeeze(-1) # (P, r)
        correction = tc.bmm(Vprec.unsqueeze(0).expand(P, -1, -1), sol.unsqueeze(-1)).squeeze(-1)  # (P,N)
        Prec_gradx = Prec_gradx - Delta_inv * correction

        temp_x     = x - Prec_gradx
        proj_temp  = proj_simplex(temp_x)
        PgradxP    = proj_temp - x
        Dx_list.append(PgradxP)

    if len(Dx_list) == 0:
        Dx_list.append(Pgradx)

    Dx = tc.stack(Dx_list, dim=1)  # (P, L, N)
    Ad = tc.zeros((P, Dx.size(1), N), dtype=dtype, device=device)
    Bx = tc.bmm(Dx, Ad.transpose(1, 2))  # (P, L, L) — ici lmbdl (comme dans la version d’origine)

    x_new, dx_new = primal_dual(xb, Dx, Bx, gradxb, sub, sup, P, N, tau)

    dynamic = [dx_new, Pgradx]
    return x_new, dynamic


def iter_P3MG(static, dynamic, x, y, lmbd, tau):
    """
    Itérations P3MG génériques (k>1).
    """
    P, N, M = x.size(0), x.size(1), y.size(1)

    Hmat, alpha, beta, eta, sub, sup, gamma, Cg2, Vprec, Sprec_2, Hnorm2 = static
    LipsMaj = lmbd * (1 / (alpha * beta) + Cg2) + Hnorm2
    dx_old, Pgradx_old = dynamic

    device = x.device
    dtype  = x.dtype

    # Statics -> device
    Hmat    = Hmat.to(device=device, dtype=dtype)
    Vprec   = Vprec.to(device=device, dtype=dtype)
    Sprec_2 = Sprec_2.to(device=device, dtype=dtype)

    # Gradient et projection
    gradx, l1 = gradient_x(x, y, Hmat, alpha, beta, eta, lmbd)
    fwd  = x - (gamma / LipsMaj) * gradx
    xb   = proj_simplex(fwd)
    Pgradx = xb - x
    gradxb, l1b = gradient_x(xb, y, Hmat, alpha, beta, eta, lmbd)

    # Sous-espace (général)
    Dx_list = []
    subspace_gen = [1, 1, 1, 1]
    if subspace_gen[0]:
        Dx_list.append(Pgradx)
    if subspace_gen[1]:
        Adiag0     = majorante_x_diag(x, alpha, l1, beta, Cg2, lmbd, 0)
        Delta_inv  = 1.0 / Adiag0
        Vprec_T    = Vprec.t().unsqueeze(0).expand(P, -1, -1)
        weighted_V = Vprec_T * Delta_inv.unsqueeze(1)
        temp_batch = tc.bmm(weighted_V, Vprec.unsqueeze(0).expand(P, -1, -1))
        diag_S     = tc.diag_embed(Sprec_2).unsqueeze(0).expand(P, -1, -1)
        temp       = diag_S + temp_batch
        Prec_gradx = Delta_inv * gradx
        temp_vec   = tc.matmul(Prec_gradx, Vprec)
        sol        = tc.linalg.solve(temp, temp_vec.unsqueeze(-1)).squeeze(-1)
        correction = tc.bmm(Vprec.unsqueeze(0).expand(P, -1, -1), sol.unsqueeze(-1)).squeeze(-1)
        Prec_gradx = Prec_gradx - Delta_inv * correction
        temp_x     = x - Prec_gradx
        proj_temp  = proj_simplex(temp_x)
        PgradxP    = proj_temp - x
        Dx_list.append(PgradxP)
    if subspace_gen[2]:
        Dx_list.append(dx_old)
    if subspace_gen[3]:
        Dx_list.append(Pgradx_old)

    if len(Dx_list) == 0:
        Dx_list.append(Pgradx)

    Dx = tc.stack(Dx_list, dim=1)  # (P, L, N)
    Ad = tc.zeros((P, Dx.size(1), N), dtype=dtype, device=device)
    Bx = tc.bmm(Dx, Ad.transpose(1, 2))  # (P, L, L) — lmbdl comme dans la version d’origine

    x_new, dx_new = primal_dual(xb, Dx, Bx, gradxb, sub, sup, P, N, tau)

    dynamic_new = [dx_new, Pgradx]
    return x_new, dynamic_new
